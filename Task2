@startuml Архитектура_АгроТех_Системы_С2_1

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(директор, "Директор хозяйства", "Управление через веб-портал")
Person(агроном, "Агроном", "Использует мобильное приложение")
Person(тепличник, "Тепличный комплекс", "Управление теплицами")
Person(механик, "Механик", "Мониторинг техники")
Person(аналитик, "Аналитик", "Работа с BI-системой")
Person(скотовод, "Скотовод", "Следит за кормлением и состоянием животных")

System_Boundary(платформа, "АгроТех Х - Цифровая платформа") {
    Container(веб_портал, "Веб-портал", "React", "Управление хозяйством")
    Container(мобильное_приложение, "Мобильное приложение", "Flutter", "Полевые работы")
    ContainerDb(erp, "ERP система (1С:Агро)", "1С", "Финансы, склад, кадры")
    
    Container_Boundary(тепличные_системы, "Тепличные комплексы") {
        Container(scada, "SCADA система", "Ignition", "Управление климатом")
        Container(тепличные_датчики, "Тепличные датчики", "Python", "Микроклимат, полив")
        Container(автополив, "Система автополива", "C++", "Управление орошением")
    }
    
    Container(kafka, "Брокер сообщений", "Apache Kafka", "Шина данных")
    
    Container_Boundary(iot_платформа, "IoT платформа") {
        Container(iot_шлюз, "IoT шлюз", "Node-RED", "Сбор данных с полей")
        Container(tsdb, "База временных рядов", "TimescaleDB", "Данные датчиков")
        Container(трекер_техники, "Трекер техники", "Java", "Мониторинг транспорта")
        Container(трекер_корма, "Трекер системы кормления скота", "Go", "Контроль кормушек и поилок")
    }
    
    Container_Boundary(полевые_данные, "Данные с полей") {
        Container(метео_данные, "Метеостанции", "Python", "Погодные условия")
        Container(почва, "Датчики почвы", "Python", "Влажность, состав")
        Container(урожайность, "Мониторинг урожая", "Python", "Камера+ИИ на технике")
    }
    
    Container_Boundary(управление_техникой, "Управление техникой") {
        Container(планировщик, "Планировщик заданий", "Kotlin", "Распределение работ")
        Container(мониторинг_гсм, "Мониторинг ГСМ", "Go", "Контроль топлива")
        Container(диагностика, "Диагностика", "C#", "Состояние техники")
    }
    
    Container_Boundary(данные, "Хранилища данных") {
        ContainerDb(data_lake, "Data Lake", "MinIO", "Сырые данные (S3-совместимое)")
        ContainerDb(dwh, "Data Warehouse", "ClickHouse", "Структурированные данные")
    }
    
    Container(bi, "BI система", "Power BI", "Отчеты и визуализация")
    Container(аналитика, "Аналитический модуль", "Python+Spark", "Анализ эффективности")
}

Container_Boundary(фермы, "Система животноводства (фермы)") {
    Container(ферм_агент, "Локальный агент фермы",  "Управление и буферизация данных")
    Container(видеоаналитика, "Видеоаналитика",  "Обработка потоков камер")
    ContainerDb(ферм_бд, "Локальная БД", "Postgres", "Хранение событий и метрик")
    Container(кормление, "Система кормления и поения", "Управление кормушками и поилками скота")
    Container(ферм_датчики, "Датчики и камеры", "Поведение, здоровье, пересчет поголовья, местоположение")
}

Rel(директор, веб_портал, "Использует")
Rel(агроном, мобильное_приложение, "Использует")
Rel(тепличник, scada, "Управляет")
Rel(механик, трекер_техники, "Мониторит")
Rel(аналитик, bi, "Анализирует")
Rel(скотовод, трекер_корма, "Мониторит и управляет фермой")

Rel(iot_шлюз, kafka, "Публикует данные", "Kafka Protocol")
Rel(тепличные_датчики, kafka, "Публикует данные", "MQTT->Kafka")
Rel(трекер_техники, kafka, "Публикует позиции", "Kafka Protocol")
Rel(трекер_корма, kafka, "Публикует данные кормления", "Kafka Protocol")
Rel(kafka, data_lake, "Сырые данные", "Kafka Connect+S3")
Rel(kafka, dwh, "Трансформированные данные", "ETL+Airflow")

Rel(scada, kafka, "Публикует климат-данные", "OPC UA->Kafka")
Rel(автополив, scada, "Получает команды", "Modbus TCP")
Rel(тепличные_датчики, scada, "Передает данные", "LoRaWAN")

Rel(метео_данные, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(почва, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(урожайность, iot_шлюз, "Передает данные", "4G")

Rel(kafka, планировщик, "Поток задач", "Kafka Protocol")
Rel(мониторинг_гсм, dwh, "Сохраняет данные", "ETL")
Rel(диагностика, erp, "Передает данные о ремонтах", "REST API")

Rel(data_lake, аналитика, "Доступ к сырым данным", "Spark")
Rel(dwh, аналитика, "Доступ к структурированным данным", "SQL")
Rel(аналитика, bi, "Передает отчеты", "ODBC")
Rel(аналитика, веб_портал, "Формирует рекомендации", "WebSocket")

Rel(веб_портал, erp, "Синхронизация данных", "REST API")
Rel(erp, dwh, "Бизнес-данные", "ETL")
Rel(мобильное_приложение, kafka, "Полевые отчеты", "Kafka Protocol")

Rel(ферм_агент, kafka, "Публикует телеметрию и события кормления")
Rel(kafka, ферм_агент, "Команды управления", "Потребители Kafka")
Rel(видеоаналитика, ферм_агент, "Отправляет результаты анализа")
Rel(ферм_датчики, видеоаналитика, "Передает поток видео/данные")
Rel(ферм_агент, ферм_бд, "Буферизация данных", "SQL")
Rel(ферм_агент, кормление, "Управление исполнительными механизмами")

@enduml



@startuml Архитектура_АгроТех_Системы__С2_2

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(директор, "Директор хозяйства", "Управление через веб-портал")
Person(агроном, "Агроном", "Использует мобильное приложение")
Person(тепличник, "Тепличный комплекс", "Управление теплицами")
Person(механик, "Механик", "Мониторинг техники")
Person(аналитик, "Аналитик", "Работа с BI-системой")
Person(скотовод, "Скотовод", "Мониторит и управляет фермой")

System_Boundary(платформа, "АгроТех Х - Цифровая платформа") {
    Container(веб_портал, "Веб-портал", "React", "Управление хозяйством")
    Container(мобильное_приложение, "Мобильное приложение", "Flutter", "Полевые работы")
    ContainerDb(erp, "ERP система (1С:Агро)", "1С", "Финансы, склад, кадры")
    
    Container_Boundary(тепличные_системы, "Тепличные комплексы") {
        Container(scada, "SCADA система", "Ignition", "Управление климатом")
        Container(тепличные_датчики, "Тепличные датчики", "Python", "Микроклимат, полив")
        Container(автополив, "Система автополива", "C++", "Управление орошением")
    }
    
    Container(kafka, "Центральный брокер сообщений", "Apache Kafka", "Шина данных внутри платформы")
    
    Container_Boundary(iot_платформа, "IoT платформа") {
        Container(iot_шлюз, "IoT шлюз", "Node-RED", "Сбор данных с полей")
        Container(tsdb, "База временных рядов", "TimescaleDB", "Данные датчиков")
        Container(трекер_техники, "Трекер техники", "Java", "Мониторинг транспорта")
        Container(трекер_корма, "Трекер системы кормления скота", "Go", "Контроль кормушек и поилок")
    }
    
    Container_Boundary(полевые_данные, "Данные с полей") {
        Container(метео_данные, "Метеостанции", "Python", "Погодные условия")
        Container(почва, "Датчики почвы", "Python", "Влажность, состав")
        Container(урожайность, "Мониторинг урожая", "Python", "Камера+ИИ на технике")
    }
    
    Container_Boundary(управление_техникой, "Управление техникой") {
        Container(планировщик, "Планировщик заданий", "Kotlin", "Распределение работ")
        Container(мониторинг_гсм, "Мониторинг ГСМ", "Go", "Контроль топлива")
        Container(диагностика, "Диагностика", "C#", "Состояние техники")
    }
    
    Container_Boundary(данные, "Хранилища данных") {
        ContainerDb(data_lake, "Data Lake", "MinIO", "Сырые данные (S3-совместимое)")
        ContainerDb(dwh, "Data Warehouse", "ClickHouse", "Структурированные данные")
    }
    
    Container(bi, "BI система", "Power BI", "Отчеты и визуализация")
    Container(аналитика, "Аналитический модуль", "Python+Spark", "Анализ эффективности")
    
    Container(центральный_агент, "Локальный агент фермы (централизованный)", "Go", "Управление связью с фермами")
}

System_Boundary(внешние_интеграции, "Интеграционный слой") {
    Container(внешняя_kafka, "Внешний брокер сообщений", "Apache Kafka", "Обмен между агентами и платформой")
}

Container_Boundary(фермы, "Система животноводства (фермы)") {
    Container(ферм_агент, "Локальный агент фермы", "Управление и буферизация данных")
    Container(видеоаналитика, "Видеоаналитика", "Обработка потоков камер")
    ContainerDb(ферм_бд, "Локальная БД", "Postgres", "Хранение событий и метрик")
    Container(кормление, "Система кормления и поения", "Управление кормушками и поилками")
    Container(ферм_датчики, "Датчики и камеры", "Поведение, здоровье, пересчет поголовья, местоположение")
}

' --- Связи пользователей ---
Rel(директор, веб_портал, "Использует")
Rel(агроном, мобильное_приложение, "Использует")
Rel(тепличник, scada, "Управляет")
Rel(механик, трекер_техники, "Мониторит")
Rel(аналитик, bi, "Анализирует")
Rel(скотовод, трекер_корма, "Следит за состоянием кормушек и поилок")

' --- Связи внутри платформы ---
Rel(iot_шлюз, kafka, "Публикует данные", "Kafka Protocol")
Rel(тепличные_датчики, kafka, "Публикует данные", "MQTT->Kafka")
Rel(трекер_техники, kafka, "Публикует позиции", "Kafka Protocol")
Rel(трекер_корма, kafka, "Публикует данные кормления", "Kafka Protocol")
Rel(kafka, data_lake, "Сырые данные", "Kafka Connect+S3")
Rel(kafka, dwh, "Трансформированные данные", "ETL+Airflow")

Rel(scada, kafka, "Публикует климат-данные", "OPC UA->Kafka")
Rel(автополив, scada, "Получает команды", "Modbus TCP")
Rel(тепличные_датчики, scada, "Передает данные", "LoRaWAN")

Rel(метео_данные, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(почва, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(урожайность, iot_шлюз, "Передает данные", "4G")

Rel(kafka, планировщик, "Поток задач", "Kafka Protocol")
Rel(мониторинг_гсм, dwh, "Сохраняет данные", "ETL")
Rel(диагностика, erp, "Передает данные о ремонтах", "REST API")

Rel(data_lake, аналитика, "Доступ к сырым данным", "Spark")
Rel(dwh, аналитика, "Доступ к структурированным данным", "SQL")
Rel(аналитика, bi, "Передает отчеты", "ODBC")
Rel(аналитика, веб_портал, "Формирует рекомендации", "WebSocket")

Rel(веб_портал, erp, "Синхронизация данных", "REST API")
Rel(erp, dwh, "Бизнес-данные", "ETL")
Rel(мобильное_приложение, kafka, "Полевые отчеты", "Kafka Protocol")

' --- Новые связи с фермами через внешнюю Kafka ---
Rel(ферм_агент, внешняя_kafka, "Публикует телеметрию и события")
Rel(внешняя_kafka, центральный_агент, "Передает данные ферм", "Kafka Protocol")
Rel(центральный_агент, kafka, "Публикует во внутреннюю шину", "Kafka Protocol")

' --- Добавляем поток команд управления ---
Rel(kafka, центральный_агент, "Команды управления", "Kafka Protocol")
Rel(центральный_агент, внешняя_kafka, "Передает команды управления", "Kafka Protocol")
Rel(внешняя_kafka, ферм_агент, "Доставляет команды на ферму", "Kafka Protocol")
Rel(ферм_агент, кормление, "Управление кормушками и поилками")

' --- Взаимодействие компонентов фермы ---
Rel(видеоаналитика, ферм_агент, "Отправляет результаты анализа")
Rel(ферм_датчики, видеоаналитика, "Передает поток видео/данные")
Rel(ферм_агент, ферм_бд, "Буферизация данных", "SQL")

@enduml



# Task2 — MVP платформы мониторинга ферм

**Содержание:**

1. Ограниченные контексты (bounded contexts) и микросервисы
2. Архитектурные решения (ADR) с компромиссами и рисками
3. Два варианта C2 (контейнерных) диаграмм
4. Интеграции между сервисами и обоснование технологий
5. Рекомендации по следующему шагу и артефакты для репозитория

---

> **Примечание:** документ описывает проект MVP — 3–5 ферм, отдельные агент-сервера на ферме (edge) и центральный сервер. Все решения ориентированы на быстрый Proof-of-Value, отказоустойчивость и возможность масштабирования в SaaS позже.

---

# 1. Ограниченные контексты и микросервисы

Ниже — набор ограниченных контекстов (bounded contexts), которые превращаются в отдельные микросервисы/агенты или подсистемы. Для каждого контекста указано, какие задачи он решает и насколько он должен быть расположен (edge / on-prem / cloud).

## 1.1 Device Gateway (Protocol Adapter)

* **Цель:** общение с датчиками, кормушками, поилками, контроллерами, GPS/OBD техники.
* **Функции:** поддержка MQTT (основной), HTTP(S), LoRaWAN/TTN (для малых сенсоров), Serial/Modbus (локально), ONVIF/RTSP для камер; перевод в внутренние события.
* **Расположение:** на ферме (агент) — локально, с возможностью туннелирования в центральный сервер.
* **Особенность:** гарантировать буферизацию при пропадании интернета.

## 1.2 Video Ingest & Edge Analytics

* **Цель:** получать видеопотоки, запускать inference нейросетей (модель поставляют партнёры) для трекинга, детекции драк, задавливания поросят, подсчёта поголовья.
* **Функции:** захват RTSP/ONVIF, декодирование, пакетная и стрим-аналитика, трекинг, агрегация событий.
* **Расположение:** на ферме (edge) — близко к камерам, для выполнения требований низкой задержки.
* **HW:** NVIDIA Jetson / Intel NCS / GPU-сервер в хлеву.

## 1.3 Device Control (Actuator Manager)

* **Цель:** управление кормушками и поилками (разные протоколы и производители).
* **Функции:** унифицированный API для команд, очереди команд, подтверждение выполнения, планировщик кормлений.
* **Расположение:** агент на ферме; облачный компонент для планов и конфигураций.

## 1.4 Telemetry & Metrics Service

* **Цель:** сбор телеметрии от устройств/агентов, хранение метрик, экспонирование метрик для мониторинга и внешних систем (Prometheus-compatible).
* **Расположение:** агент (кеширование) + центральный (кумуляция, long-term storage).

## 1.5 Farm Sync Agent (Edge Agent)

* **Цель:** локальный оркестратор данных на ферме: кеширование событий, локальная БД, рабочие очереди, офлайн-управление пользователями на месте, локальные уведомления.
* **Функции:** локальная PostgreSQL (или SQLite → Postgres), очередь (RabbitMQ lightweight / embedded), синхронизация с центральным сервером (периодически, задержка до 10 минут допускается).

## 1.6 Central API / Control Plane

* **Цель:** единая точка управления, UI, аутентификация, аудит, агрегированная аналитика и долгосрочное хранение.
* **Функции:** REST/gRPC API, OAuth2/OIDC, RBAC, интеграция с мобильными приложениями.

## 1.7 Video Analytics Service (Central)

* **Цель:** доп. аналитика, обучение и бэк-тестирование моделей, ретроспективный анализ.
* **Расположение:** cloud/central (тяжёлые расчёты, тренировка моделей).

## 1.8 Alerts & Notification Service

* **Цель:** маршрутизация оповещений операторов: SMS, Push, горячая линия на ферме (локально), IVR/телефон.
* **Функции:** политики умножения, дедупликация, эскалации.

## 1.9 Inventory & Feed Forecasting

* **Цель:** управление запасами корма, прогнозы расхода на основе телеметрии (сколько кормлений, средний расход), интеграция с покупками/логистикой.
* **Расположение:** центральный (forecast), локальная копия для офлайн.

## 1.10 AuthN/AuthZ & Audit

* **Цель:** современная аутентификация (OIDC), RBAC, MFA, аудит команд управления кормушками.
* **Расположение:** центральный, с локальным кешем токенов и групп.

## 1.11 Admin / Device Management

* **Цель:** provisioning устройств, firmware updates, certificate management.
* **Расположение:** cloud + agent.

---

# 2. Архитектурные решения (ADR)

Ниже — набор ключевых ADR с описанием контекста, решения, альтернатив, компромиссов и рисков.

## ADR-001: Выбор брокера сообщений между агентом и центральным сервером

* **Контекст:** необходимо надежно передавать телеметрию, события и команды; допуск задержки синхронизации до 10 минут.
* **Решение:** использовать **RabbitMQ** для команд/телеметрии и **MQTT** (встроенный брокер или через RabbitMQ MQTT plugin) для устройств. Вариант II — использовать **Kafka** для высокой нагрузки и стрим-аналитики (см. альтернативная C2).
* **Обоснование:** RabbitMQ прост в эксплуатации, поддерживает MQTT (посредством плагина), подходит для сценариев с низкой/средней нагрузкой и гарантированной доставкой, малотребователен к ресурсам на edge.
* **Компромиссы:** при значительном росте (тысячи сообщений/сек) RabbitMQ потребует кластеризации и усложнения; Kafka даёт лучшую пропускную способность и репликацию, но сложнее для edge (ресурсно тяжёлый).
* **Риски:** перегрузка при пиковой нагрузке → план миграции к Kafka/stream platform.

## ADR-002: Где запускать видеоаналитику (edge vs cloud)

* **Контекст:** требование — оповещение по видеоалярмам не позднее 5 секунд; real-time (миллисекунды) для видео-аналитики.
* **Решение:** **основной inference — на edge** (NVIDIA Jetson/локальный GPU). В центральном: ретроспективная аналитика и обучение.
* **Обоснование:** минимальная задержка, экономия пропускной способности (не нужно слать весь поток в облако), работа при отсутствии интернета.
* **Компромиссы:** ограниченные ресурсы на edge; сложность управления версиями моделей.
* **Риски:** модель путает тени; ограниченное качество при ночной съемке; нужно robust preprocessing (IR/LED подсветка, инфракрас). Решение: комбинировать ночные камеры + IR + нормализацию входа и confidence thresholds.

## ADR-003: Протокол устройств

* **Решение:** для сенсоров/актуаторов — **MQTT** (topic per farm/device), для камер — **RTSP/ONVIF**; для долгосрочных интеграций — HTTP REST/gRPC.
* **Обоснование:** MQTT лёгок, работает через нестабильные соединения, поддерживает QoS (0/1/2), широко распространён.
* **Компромиссы:** MQTT не идеален для больших payload'ов (видео) — потому RTSP отдельно.
* **Риски:** разные вендоры требуют адаптеров — нужно Device Gateway.

## ADR-004: База данных для телеметрии и событий

* **Решение (вариант A):** PostgreSQL + TimescaleDB для временных рядов (metrics), S3 для видео/архива; объектное хранилище для видеофрагментов.
* **Альтернатива (вариант B):** ClickHouse для аналитики больших объёмов и хранения событий / быстрых запросов.
* **Обоснование:** TimescaleDB даёт ACID и удобство SQL + время-серийные функции. ClickHouse быстрее для аналитических запросов, но не подходит для transactional workloads (например, управление устройствами).
* **Компромиссы:** TimescaleDB — ощутимо удобнее при транзакциях и справляется с высокой нагрузкой, но при экстремальной аналитике стоит использовать ClickHouse как OLAP.
* **Риски:** рост данных видео → поставить lifecycle (ретеншен, архив в холодное хранилище).

## ADR-005: API (внутреннее/внешнее)

* **Решение:** внешнее API — REST + OpenAPI для мобильных/веб клиентов; внутренняя коммуникация latency-sensitive — gRPC между центральными сервисами.
* **Обоснование:** REST удобен для внешних приложений; gRPC даёт низкую задержку и contract-first подход для микросервисов.
* **Компромиссы:** поддержка двух стилей требует шаблонов и трансляторов.
* **Риски:** сложности с дебагом gRPC в раннем этапе — применяем observability.

## ADR-006: Аутентификация и авторизация

* **Решение:** OIDC (keycloak/OPA для RBAC) + JWT с коротким TTL; на ферме — локальный кеш ключей и offline token refresh flow.
* **Обоснование:** современные, поддерживают MFA и интеграции.
* **Риски:** компрометация ключей → план rotation и HSM/KeyVault.

## ADR-007: Оповещения и офлайн уведомления

* **Решение:** Alerts service использует локальную очередь для immediate push (SMS/SMS-gateway via cellular modem) и push notifications через cloud. На ферме — loudspeaker / SMS / local staff push.
* **Риски:** ложные срабатывания — настроить confidence thresholds и эскалацию.

## ADR-008: Синхронизация и офлайн-first

* **Решение:** локальная БД (Postgres w/ WAL, или SQLite для самой легкой установки) + механизм периодической синхронизации (CDC/Change-sets) с retry и конфликт-решением (LWW для телеметрии, CRDT/операции для команд).
* **Обоснование:** гарантирует работу при отсутствии интернета.
* **Риски:** конфликты состояния → хранить authoritative state в центральном, но позволять локальные правки только для операций на местах.

---

# 3. Два варианта C2 (контейнерных диаграмм)

Ниже — два варианта C2. Первый ориентирован на быстрый MVP с низким ресурсным порогом (RabbitMQ + Postgres + edge inference). Второй — на более производительную стриминговую платформу (Kafka, ClickHouse/TimescaleDB) для больших ферм и SaaS-скейла.

> В каждой диаграмме указаны контейнеры (процессы), их роль, интерфейсы и размещение (Edge vs Central/Cloud).

---

## Вариант A (MVP, рекомендуемый для начала): RabbitMQ / MQTT / Postgres / Edge inference

```mermaid
flowchart TB
  subgraph FarmEdge[Farm Agent — Edge]
    CameraPool((Камеры (RTSP/ONVIF)))
    EdgeIngest[Video Ingest & Edge Analytics]
    DeviceGW[Device Gateway (MQTT client)]
    LocalDB[(Postgres (local, wal))]
    LocalQueue[(RabbitMQ-lite)]
    ActuatorMgr[Actuator Manager]
    LocalUI[Local Dashboard / Notifications]
    Cellular[Cellular modem / LTE]
  end

  subgraph Central[Central Cloud]
    Broker[(RabbitMQ cluster + MQTT plugin)]
    API[Central API (REST/gRPC)]
    Auth[AuthN/OIDC]
    Metrics[(TimescaleDB/Postgres)]
    VideoStore[(S3 / MinIO)]
    AlertSrv[Alert & Notification Service]
    AdminUI[Web/Mobile UI]
  end

  CameraPool -->|RTSP| EdgeIngest
  EdgeIngest -->|events| LocalQueue
  DeviceGW -->|telemetry (MQTT)| LocalQueue
  ActuatorMgr -->|commands| LocalQueue
  LocalQueue -->|sync (AMQP)| Broker
  Broker --> API
  API --> Metrics
  EdgeIngest -->|archive| VideoStore
  API --> AdminUI
  AlertSrv --> AdminUI
  Broker --> Auth
  LocalDB --> EdgeIngest
  LocalDB --> DeviceGW

```

**Ключевые моменты варианта A:**

* Edge выполняет inference, шлет события в RabbitMQ; центральный брокер аккумулирует события.
* LocalDB обеспечивает офлайн-first поведение и буферизацию.
* Простой стек быстрее в развертывании и менее ресурсоёмок.

---

## Вариант B (Stream-first, для масштаба): Kafka / ClickHouse / Centralized Analytics

```mermaid
flowchart TB
  subgraph FarmEdge[Farm Edge]
    Cameras((RTSP stream))
    EdgeIngest2[FFmpeg -> Edge Inference (GPU)]
    MQProxy[MQProducer (Kafka REST Proxy)]
    LocalCache[(RocksDB / SQLite)]
    ActuatorKM[Command Manager]
    LTE[Cellular modem]
  end

  subgraph Cloud[Cloud]
    Kafka[(Kafka Cluster)]
    StreamProc[Kafka Streams / Flink]
    OLAP[(ClickHouse)]
    TSDB[(TimescaleDB for transactional metrics)]
    API2[Central gRPC/REST]
    ModelTrain[Model Training (GPU pool)]
    AlertEngine[Realtime Alerting]
  end

  Cameras -->|RTSP| EdgeIngest2
  EdgeIngest2 -->|events -> Kafka REST| MQProxy
  MQProxy --> Kafka
  Kafka --> StreamProc
  StreamProc --> OLAP
  StreamProc --> AlertEngine
  API2 --> TSDB
  AlertEngine -->|notify| AdminUI
  ModelTrain --> StreamProc

```

**Ключевые моменты варианта B:**

* Kafka даёт высокую пропускную способность и хорош для ретроспективных вычислений и ML-пайплайнов.
* Стоимость и сложность больше, особенно для edge — потребуется Kafka proxy или lightweight producer.

---

# 4. Интеграции между сервисами и обоснование

Ниже приведён список интеграций, формат сообщений и аргументы в пользу выбора технологий.

## 4.1 Камеры -> Edge Ingest

* **Протокол:** RTSP/ONVIF  
* **Причина:** это стандарт видеонаблюдения; большинство IP-камер поддерживает RTSP.  
* **Требования:** низкая задержка, поддержка инфракрасного режима для ночной съёмки. Используется аппаратное декодирование (hardware decoding), FFMPEG/GStreamer.  
* **Формат событий:** JSON-манифесты с ссылками на ключевые фрагменты видео (ID объекта в S3) и метаданными (timestamp, camera_id, bbox, confidence).  

## 4.2 Устройства (сенсоры/кормушки/поилки) <-> Device Gateway

* **Протокол:** MQTT (topic farm/{farmId}/{deviceType}/{deviceId}), QoS=1 для критичных команд.  
* **Причина:** простота реализации, стабильная работа при нестабильных сетях.  
* **Команды:** JSON, с определением схемы и версии (при изменении API используются versioned topics).  

## 4.3 Edge -> Central (события/телеметрия)

* **Протокол:** AMQP через RabbitMQ или REST Proxy для Kafka; события — небольшие JSON-сообщения; видео архивируется отдельно в объектное хранилище.  
* **Обоснование:** гарантированная доставка сообщений, повторные попытки, сохранность данных.  

## 4.4 Central API -> UI/Mobile

* **Протокол:** HTTPS + OpenAPI (REST). Для real-time интерфейсов используется WebSockets или Server-Sent Events (SSE) для push-уведомлений.  

## 4.5 Alerts -> Каналы уведомлений

* **Интеграции:** SMS-шлюз (SMPP/HTTP), Push-уведомления (FCM/APNs), локальный GSM-модем для SMS на ферме, VoIP-шлюз для звонков.  
* **Логика:** мультиканальная доставка, эскалация, дедупликация уведомлений.  

## 4.6 Хранение данных

* **Видео:** S3-совместимое хранилище (MinIO on-prem или AWS S3). Миниатюры и метаданные в базе данных, исходное видео — в объектном хранилище с политиками жизненного цикла.  
* **Телеметрия:** TimescaleDB/Postgres для временных рядов, ClickHouse для аналитики при необходимости.  

## 4.7 Метрики и мониторинг

* **Сбор:** Prometheus-экспортеры на сервисах, дашборды Grafana. Центральный агрегатор метрик (Prometheus TSDB или remote write в TimescaleDB).  
* **Трассировка:** OpenTelemetry, Jaeger collector для распределенного трейсинга.


---

# 5. Компромиссы и риски (сводно)

* **Edge inference vs central:** Edge минимизирует задержку, но усложняет управление моделями и обновлениями. Компромисс:









# ADR и архитектура MVP платформы мониторинга свиноводческих ферм

## Ограниченные контексты (Bounded Contexts)

1. **Видеоаналитика и трекинг**
   Отвечает за обработку потоков с камер, определение поведения животных, пересчёт поголовья, фиксацию аномалий (драки, болезни, гибель, задавливание поросят).

2. **Управление устройствами (Actuator Control)**
   Работа с кормушками, поилками, датчиками фильтрации воды. Унифицированный интерфейс к оборудованию разных производителей.

3. **Мониторинг инфраструктуры фермы**
   Контроль за состоянием серверов, edge-устройств, сетей и альтернативных каналов связи.

4. **Склад и прогнозирование кормов**
   Учёт запасов, прогноз потребления, метрики для ERP.

5. **Центральная аналитическая система**
   Сбор данных с ферм, консолидация, оповещения, предоставление API для мобильных и веб-приложений.

6. **Аутентификация и авторизация**
   Поддержка ролевой модели, современных методов аутентификации (OIDC, OAuth2).

---

## ADR (Architectural Decision Records)

### ADR-1 — Взаимодействие с оборудованием

* **Решение**: Использовать MQTT как основной протокол для взаимодействия с датчиками и устройствами.
* **Плюсы**: лёгкий, поддерживает плохие сети, массово используется в IoT.
* **Минусы**: ограниченные возможности брокера при больших нагрузках.
* **Риск**: при масштабировании на десятки тысяч устройств может потребоваться Kafka или специализированные шины.

### ADR-2 — Очередь сообщений

* **Решение**: RabbitMQ в MVP, с возможностью перехода на Kafka.
* **Плюсы**: поддержка MQTT-плагина, простота, кластеризация, малые ресурсы.
* **Минусы**: ограниченная производительность на экстремальных нагрузках.
* **Риск**: возможный редизайн архитектуры при SaaS-масштабировании.

### ADR-3 — Хранение данных

* **Решение**: Postgres (с расширением TimescaleDB для временных рядов) + S3-хранилище для видео.
* **Плюсы**: зрелые технологии, совместимость, лёгкость поддержки.
* **Минусы**: ограниченная масштабируемость Postgres.
* **Риск**: при росте данных потребуется шардирование или миграция в распределённые СУБД (ClickHouse, Cassandra).

### ADR-4 — Обработка видео

* **Решение**: inference на edge-устройствах, хранение только событий и метаданных, а не полного потока.
* **Плюсы**: экономия трафика, минимальная задержка.
* **Минусы**: стоимость edge-оборудования (GPU, ASIC).
* **Риск**: сложность обновления моделей на фермах.

### ADR-5 — Отказоустойчивость

* **Решение**: дублирование каналов связи (WiFi + LTE), локальные агенты с кешированием данных.
* **Плюсы**: автономность даже при падении интернета.
* **Минусы**: увеличение стоимости инфраструктуры.
* **Риск**: высокая зависимость от качества LTE покрытия.

---

## Варианты Container Diagram (C4, PlantUML)

### Вариант A — RabbitMQ / MQTT / Edge inference

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(operator, "Фермер/Оператор")
Person(admin, "Администратор")

System_Boundary(farm, "Farm Edge") {
  Container(camera, "Камеры", "RTSP/ONVIF", "Видеопотоки")
  Container(edge, "Edge Analytics", "Python/C++", "Обработка видео, выявление аномалий")
  Container(deviceGw, "Device Gateway", "MQTT Client", "Телеметрия от датчиков и устройств")
  Container(localDB, "Local DB", "Postgres", "Буферизация данных")
  Container(localQueue, "Local Queue", "RabbitMQ", "Локальная шина сообщений")
  Container(actuator, "Actuator Manager", "Service", "Управление кормушками/поилками")
}

System_Boundary(cloud, "Central Cloud") {
  Container(broker, "RabbitMQ Cluster", "AMQP/MQTT", "Центральная очередь сообщений")
  Container(api, "Central API", "REST/gRPC", "Основной API для UI и интеграций")
  Container(auth, "Auth Service", "Keycloak/OIDC", "Аутентификация и авторизация")
  Container(db, "Metrics DB", "Postgres+TimescaleDB", "Хранение временных рядов")
  Container(store, "Video Store", "S3/MinIO", "Хранение видеособытий")
  Container(alert, "Alert Service", "Service", "Формирование и доставка уведомлений")
  Container(ui, "Web/Mobile UI", "React/Flutter", "Интерфейс пользователя")
}

Rel(operator, ui, "Работа через")
Rel(admin, ui, "Администрирование")
Rel(camera, edge, "Передача видеопотока")
Rel(edge, localQueue, "События и метаданные")
Rel(deviceGw, localQueue, "MQTT сообщения")
Rel(actuator, localQueue, "Команды управления")
Rel(localQueue, broker, "AMQP sync")
Rel(broker, api, "События и данные")
Rel(api, db, "Сохранение метрик")
Rel(edge, store, "Архивирование событий")
Rel(api, ui, "REST/gRPC")
Rel(alert, ui, "Уведомления")
Rel(broker, auth, "Аутентификация")

@enduml
```

---

### Вариант B — Kafka / ClickHouse / Centralized Analytics

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

Person(operator, "Фермер/Оператор")
Person(admin, "Администратор")

System_Boundary(farm, "Farm Edge") {
  Container(cameras, "Камеры", "RTSP", "Видеопотоки")
  Container(edge2, "Edge Inference", "GPU Service", "Обработка видео в реальном времени")
  Container(proxy, "Kafka REST Proxy", "Proxy", "Публикация событий в Kafka")
  Container(localCache, "Local Cache", "SQLite/RocksDB", "Буферизация событий")
  Container(actuatorKM, "Command Manager", "Service", "Локальное управление устройствами")
}

System_Boundary(cloud, "Central Cloud") {
  Container(kafka, "Kafka Cluster", "Kafka", "Основная шина событий")
  Container(stream, "Stream Processing", "Kafka Streams/Flink", "Аналитика в реальном времени")
  Container(olap, "OLAP DB", "ClickHouse", "Хранение аналитики")
  Container(tsdb, "Metrics DB", "TimescaleDB", "Хранение метрик")
  Container(api2, "Central API", "REST/gRPC", "Основной API для UI и интеграций")
  Container(model, "Model Training", "GPU Pool", "Обучение и обновление моделей")
  Container(alert2, "Alert Engine", "Service", "Генерация уведомлений")
  Container(ui2, "Web/Mobile UI", "React/Flutter", "Интерфейс пользователя")
}

Rel(operator, ui2, "Работа через")
Rel(admin, ui2, "Администрирование")
Rel(cameras, edge2, "Передача видео")
Rel(edge2, proxy, "События")
Rel(proxy, kafka, "Отправка событий")
Rel(kafka, stream, "Потоковые данные")
Rel(stream, olap, "Сохранение аналитики")
Rel(stream, alert2, "События для уведомлений")
Rel(api2, tsdb, "Метрики")
Rel(alert2, ui2, "Уведомления")
Rel(model, stream, "Новые модели для анализа")

@enduml
```

---

Теперь у вас полноценные **Container diagrams** (C4) для двух вариантов архитектуры MVP.



@startuml Архитектура_АгроТех_Системы_v5

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

' === Участники ===
Person(директор, "Директор хозяйства", "Управление через веб-портал")
Person(агроном, "Агроном", "Использует мобильное приложение")
Person(тепличник, "Тепличный комплекс", "Управление теплицами")
Person(механик, "Механик", "Мониторинг техники")
Person(аналитик, "Аналитик", "Работа с BI-системой")

System_Boundary(платформа, "АгроПром Х - Цифровая платформа") {
    Container(веб_портал, "Веб-портал", "React", "Управление хозяйством")
    Container(мобильное_приложение, "Мобильное приложение", "Flutter", "Полевые работы")
    ContainerDb(erp, "ERP система (1С:Агро)", "1С", "Финансы, склад, кадры")
    
    Container_Boundary(тепличные_системы, "Тепличные комплексы") {
        Container(scada, "SCADA система", "Ignition", "Управление климатом")
        Container(тепличные_датчики, "Тепличные датчики", "Python", "Микроклимат, полив")
        Container(автополив, "Система автополива", "C++", "Управление орошением")
    }
    
    Container(kafka, "Брокер сообщений", "Apache Kafka", "Шина данных")
    
    Container_Boundary(iot_платформа, "IoT платформа") {
        Container(iot_шлюз, "IoT шлюз", "Node-RED", "Сбор данных с полей")
        Container(tsdb, "База временных рядов", "TimescaleDB", "Данные датчиков")
        Container(трекер_техники, "Трекер техники", "Java", "Мониторинг транспорта")
    }
    
    Container_Boundary(полевые_данные, "Данные с полей") {
        Container(метео_данные, "Метеостанции", "Python", "Погодные условия")
        Container(почва, "Датчики почвы", "Python", "Влажность, состав")
        Container(урожайность, "Мониторинг урожая", "Python", "Камера+ИИ на технике")
    }
    
    Container_Boundary(управление_техникой, "Управление техникой") {
        Container(планировщик, "Планировщик заданий", "Kotlin", "Распределение работ")
        Container(мониторинг_гсм, "Мониторинг ГСМ", "Go", "Контроль топлива")
        Container(диагностика, "Диагностика", "C#", "Состояние техники")
    }
    
    Container_Boundary(данные, "Хранилища данных") {
        ContainerDb(data_lake, "Data Lake", "MinIO", "Сырые данные (S3-совместимое)")
        ContainerDb(dwh, "Data Warehouse", "ClickHouse", "Структурированные данные")
    }
    
    Container(bi, "BI система", "Power BI", "Отчеты и визуализация")
    Container(аналитика, "Аналитический модуль", "Python+Spark", "Анализ эффективности")
}

' === Животноводческие фермы ===
Container_Boundary(фермы, "Система животноводства (фермы)") {
    Container(ферм_агент, "Edge Agent фермы", "Go/Python", "Управление и буферизация данных")
    Container(видеоаналитика, "Видеоаналитика", "Python+TensorRT", "Обработка потоков камер")
    ContainerDb(ферм_бд, "Локальная БД", "Postgres/SQLite", "Хранение событий и метрик")
    Container(кормление, "Система кормления и поения", "PLC/C++", "Управление кормушками и поилками")
    Container(ферм_датчики, "Датчики и камеры", "RTSP/MQTT", "Поведение, здоровье, пересчет поголовья")
}

' === Взаимосвязи ===
Rel(директор, веб_портал, "Использует")
Rel(агроном, мобильное_приложение, "Использует")
Rel(тепличник, scada, "Управляет")
Rel(механик, трекер_техники, "Мониторит")
Rel(аналитик, bi, "Анализирует")

' Центральная Kafka
Rel(iot_шлюз, kafka, "Публикует данные", "Kafka Protocol")
Rel(тепличные_датчики, kafka, "Публикует данные", "MQTT->Kafka")
Rel(трекер_техники, kafka, "Публикует позиции", "Kafka Protocol")
Rel(kafka, data_lake, "Сырые данные", "Kafka Connect+S3")
Rel(kafka, dwh, "Трансформированные данные", "ETL+Airflow")

' Тепличные системы
Rel(scada, kafka, "Публикует климат-данные", "OPC UA->Kafka")
Rel(автополив, scada, "Получает команды", "Modbus TCP")
Rel(тепличные_датчики, scada, "Передает данные", "LoRaWAN")

' Полевые данные
Rel(метео_данные, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(почва, iot_шлюз, "Передает данные", "LoRaWAN")
Rel(урожайность, iot_шлюз, "Передает данные", "4G")

' Управление техникой
Rel(kafka, планировщик, "Поток задач", "Kafka Protocol")
Rel(мониторинг_гсм, dwh, "Сохраняет данные", "ETL")
Rel(диагностика, erp, "Передает данные о ремонтах", "REST API")

' Аналитика
Rel(data_lake, аналитика, "Доступ к сырым данным", "Spark")
Rel(dwh, аналитика, "Доступ к структурированным данным", "SQL")
Rel(аналитика, bi, "Передает отчеты", "ODBC")
Rel(аналитика, веб_портал, "Формирует рекомендации", "WebSocket")

' ERP интеграция
Rel(веб_портал, erp, "Синхронизация данных", "REST API")
Rel(erp, dwh, "Бизнес-данные", "ETL")
Rel(мобильное_приложение, kafka, "Полевые отчеты", "Kafka Protocol")

' Интеграция фермы с платформой
Rel(ферм_агент, kafka, "Публикует телеметрию и события", "MQTT->Kafka")
Rel(kafka, ферм_агент, "Команды управления", "Kafka Consumer")
Rel(видеоаналитика, ферм_агент, "Отправляет результаты анализа", "gRPC/REST")
Rel(ферм_датчики, видеоаналитика, "Передает поток видео", "RTSP")
Rel(ферм_агент, ферм_бд, "Буферизация данных", "SQL")
Rel(ферм_агент, кормление, "Управление исполнительными механизмами", "Modbus/OPC UA")

@enduml
